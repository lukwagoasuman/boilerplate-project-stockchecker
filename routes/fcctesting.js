/*
*
*
*
*
*
*
*
*
*
*
*
*       DO NOT EDIT THIS FILE
*       For FCC testing purposes!
*
*
*
*
*
*
*
*
*
*
*
*/

'use strict';

const cors = require('cors');
const fs = require('fs').promises;
const runner = require('../test-runner');

module.exports = (app) => {
  // Serve the content of server.js
  app.route('/_api/server.js')
    .get(async (req, res, next) => {
      console.log('requested');
      try {
        const data = await fs.readFile(__dirname + '/server.js', 'utf8');
        res.send(data);
      } catch (err) {
        next(err);
      }
    });

  // Serve the content of api.js
  app.route('/_api/routes/api.js')
    .get(async (req, res, next) => {
      console.log('requested');
      try {
        const data = await fs.readFile(__dirname + '/routes/api.js', 'utf8');
        res.type('txt').send(data);
      } catch (err) {
        next(err);
      }
    });

  // Serve the content of convertHandler.js
  app.route('/_api/controllers/convertHandler.js')
    .get(async (req, res, next) => {
      console.log('requested');
      try {
        const data = await fs.readFile(__dirname + '/controllers/convertHandler.js', 'utf8');
        res.type('txt').send(data);
      } catch (err) {
        next(err);
      }
    });

  // Get tests
  app.get('/_api/get-tests', cors(), (req, res, next) => {
    console.log('requested');
    if (process.env.NODE_ENV === 'test') return next();
    res.json({ status: 'unavailable' });
  }, (req, res, next) => {
    if (!runner.report) return next();
    res.json(testFilter(runner.report, req.query.type, req.query.n));
  }, (req, res) => {
    runner.on('done', (report) => {
      process.nextTick(() => res.json(testFilter(runner.report, req.query.type, req.query.n)));
    });
  });

  // Get application info
  app.get('/_api/app-info', (req, res) => {
    const headers = Object.keys(res.getHeaders())
      .filter(h => !h.match(/^access-control-\w+/))
      .reduce((obj, h) => {
        obj[h] = res.getHeader(h);
        return obj;
      }, {});

    // Remove 'strict-transport-security' header
    delete headers['strict-transport-security'];

    res.json({ headers });
  });
};

// Filter tests based on type and optional index
function testFilter(tests, type, n) {
  let filteredTests;

  switch (type) {
    case 'unit':
      filteredTests = tests.filter(t => t.context.includes('Unit Tests'));
      break;
    case 'functional':
      filteredTests = tests.filter(t => t.context.includes('Functional Tests') && !t.title.includes('#example'));
      break;
    default:
      filteredTests = tests;
  }

  if (n !== undefined) {
    return filteredTests[n] || filteredTests;
  }

  return filteredTests;
}